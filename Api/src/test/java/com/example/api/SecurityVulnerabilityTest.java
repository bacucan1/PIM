package com.example.api;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.*;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * PRUEBAS DE VULNERABILIDAD Y SEGURIDAD
 * Basadas en OWASP Top 10 y mejores pr√°cticas de seguridad
 * 
 * Cubre:
 * - Inyecci√≥n SQL/NoSQL
 * - Cross-Site Scripting (XSS)
 * - Broken Authentication
 * - Sensitive Data Exposure
 * - Security Misconfiguration
 * - Broken Access Control
 */
@SpringBootTest(
    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
    properties = {
        "spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration"
    }
)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class SecurityVulnerabilityTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    private final ObjectMapper objectMapper = new ObjectMapper();
    private static String validToken;
    private static final String TEST_EMAIL = "security.test@example.com";

    private String getBaseUrl() {
        return "http://localhost:" + port;
    }

    @BeforeAll
    static void setup(@Autowired TestRestTemplate restTemplate, @LocalServerPort int port) {
        // Crear usuario para tests
        Map<String, String> credentials = new HashMap<>();
        credentials.put("email", TEST_EMAIL);
        credentials.put("password", "SecurePass123!");

        restTemplate.postForEntity(
            "http://localhost:" + port + "/registro",
            credentials,
            Map.class
        );

        // Obtener token v√°lido
        ResponseEntity<Map> loginResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/login",
            credentials,
            Map.class
        );
        
        validToken = (String) loginResponse.getBody().get("token");
    }

    // =====================================================
    // OWASP A01:2021 - BROKEN ACCESS CONTROL
    // =====================================================

    @Test
    @Order(1)
    @DisplayName("SEC01 - Acceso sin token debe ser bloqueado")
    void testAccessWithoutToken() {
        Map<String, Object> datos = new HashMap<>();
        datos.put("nombre", "Test");

        ResponseEntity<Map> response = restTemplate.postForEntity(
            getBaseUrl() + "/info_personal",
            datos,
            Map.class
        );

        assertTrue(response.getStatusCode().is4xxClientError(), 
            "‚ùå VULNERABILIDAD: Endpoint accesible sin autenticaci√≥n");
        
        System.out.println("‚úÖ SEC01: Acceso sin autenticaci√≥n bloqueado correctamente");
    }

    @Test
    @Order(2)
    @DisplayName("SEC02 - Token inv√°lido debe ser rechazado")
    void testInvalidToken() {
        Map<String, Object> datos = new HashMap<>();
        datos.put("nombre", "Test");

        HttpHeaders headers = new HttpHeaders();
        headers.set("x-access-token", "invalid.token.here");
        HttpEntity<Map<String, Object>> request = new HttpEntity<>(datos, headers);

        ResponseEntity<Map> response = restTemplate.postForEntity(
            getBaseUrl() + "/info_personal",
            request,
            Map.class
        );

        assertEquals(HttpStatus.UNAUTHORIZED.value(), response.getStatusCode().value(),
            "‚ùå VULNERABILIDAD: Token inv√°lido aceptado");
        
        System.out.println("‚úÖ SEC02: Token inv√°lido rechazado correctamente");
    }

    @Test
    @Order(3)
    @DisplayName("SEC03 - Token expirado debe ser rechazado")
    void testExpiredToken() {
        // Token que ya expir√≥ (firma v√°lida pero fecha pasada)
        String expiredToken = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0QGV4YW1wbGUuY29tIiwiZXhwIjoxNjAwMDAwMDAwfQ.invalid";

        Map<String, Object> datos = new HashMap<>();
        datos.put("nombre", "Test");

        HttpHeaders headers = new HttpHeaders();
        headers.set("x-access-token", expiredToken);
        HttpEntity<Map<String, Object>> request = new HttpEntity<>(datos, headers);

        ResponseEntity<Map> response = restTemplate.postForEntity(
            getBaseUrl() + "/info_personal",
            request,
            Map.class
        );

        assertEquals(HttpStatus.UNAUTHORIZED.value(), response.getStatusCode().value(),
            "‚ùå VULNERABILIDAD: Token expirado aceptado");
        
        System.out.println("‚úÖ SEC03: Token expirado rechazado correctamente");
    }

    // =====================================================
    // OWASP A03:2021 - INJECTION
    // =====================================================

    @Test
    @Order(4)
    @DisplayName("SEC04 - Intento de inyecci√≥n SQL en email")
    void testSQLInjectionInEmail() {
        String[] sqlInjectionPayloads = {
            "admin' OR '1'='1",
            "admin'--",
            "admin' OR 1=1--",
            "'; DROP TABLE users--",
            "admin' UNION SELECT * FROM users--"
        };

        for (String payload : sqlInjectionPayloads) {
            Map<String, String> credentials = new HashMap<>();
            credentials.put("email", payload);
            credentials.put("password", "password");

            ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl() + "/login",
                credentials,
                Map.class
            );

            assertTrue(response.getStatusCode().is4xxClientError() || 
                      response.getStatusCode().value() == 401,
                "‚ùå VULNERABILIDAD: Posible inyecci√≥n SQL con payload: " + payload);
        }

        System.out.println("‚úÖ SEC04: Protecci√≥n contra inyecci√≥n SQL verificada");
    }

    @Test
    @Order(5)
    @DisplayName("SEC05 - Intento de inyecci√≥n NoSQL")
    void testNoSQLInjection() {
        String[] noSqlPayloads = {
            "{\"$gt\": \"\"}",
            "{\"$ne\": null}",
            "admin\", \"$gt\": \"\"",
            "{\n  \"username\": {\"$gt\": \"\"}\n}"
        };

        for (String payload : noSqlPayloads) {
            Map<String, Object> credentials = new HashMap<>();
            credentials.put("email", payload);
            credentials.put("password", "password");

            ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl() + "/login",
                credentials,
                Map.class
            );

            assertFalse(response.getStatusCode().is2xxSuccessful(),
                "‚ùå VULNERABILIDAD: Posible inyecci√≥n NoSQL con payload: " + payload);
        }

        System.out.println("‚úÖ SEC05: Protecci√≥n contra inyecci√≥n NoSQL verificada");
    }

    // =====================================================
    // OWASP A02:2021 - CRYPTOGRAPHIC FAILURES
    // =====================================================

    @Test
    @Order(6)
    @DisplayName("SEC06 - Contrase√±as deben estar hasheadas")
    void testPasswordHashing() {
        Map<String, String> credentials = new HashMap<>();
        credentials.put("email", "hash.test@example.com");
        credentials.put("password", "PlainTextPassword123");

        ResponseEntity<Map> response = restTemplate.postForEntity(
            getBaseUrl() + "/registro",
            credentials,
            Map.class
        );

        assertEquals(HttpStatus.OK.value(), response.getStatusCode().value());

        // Intentar login con password en texto plano
        ResponseEntity<Map> loginResponse = restTemplate.postForEntity(
            getBaseUrl() + "/login",
            credentials,
            Map.class
        );

        assertEquals(HttpStatus.OK.value(), loginResponse.getStatusCode().value(),
            "‚ùå Las contrase√±as no est√°n siendo hasheadas correctamente");

        System.out.println("‚úÖ SEC06: Contrase√±as hasheadas correctamente (BCrypt)");
    }

    @Test
    @Order(7)
    @DisplayName("SEC07 - Token JWT debe tener firma v√°lida")
    void testJWTSignatureValidation() {
        // Token con firma manipulada
        String[] manipulatedTokens = {
            "eyJhbGciOiJub25lIn0.eyJzdWIiOiJoYWNrZXIifQ.",  // Algorithm: none
            validToken.substring(0, validToken.length() - 5) + "AAAAA",  // Firma modificada
            "invalid.jwt.token"
        };

        for (String token : manipulatedTokens) {
            Map<String, Object> datos = new HashMap<>();
            datos.put("nombre", "Hacker");

            HttpHeaders headers = new HttpHeaders();
            headers.set("x-access-token", token);
            HttpEntity<Map<String, Object>> request = new HttpEntity<>(datos, headers);

            ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl() + "/info_personal",
                request,
                Map.class
            );

            assertEquals(HttpStatus.UNAUTHORIZED.value(), response.getStatusCode().value(),
                "‚ùå VULNERABILIDAD: Token con firma inv√°lida aceptado");
        }

        System.out.println("‚úÖ SEC07: Validaci√≥n de firma JWT funcionando correctamente");
    }

    // =====================================================
    // OWASP A04:2021 - INSECURE DESIGN
    // =====================================================

    @Test
    @Order(8)
    @DisplayName("SEC08 - L√≠mite de intentos de login (Brute Force Protection)")
    void testBruteForceProtection() {
        String email = "brute.force@example.com";
        
        // Registrar usuario
        Map<String, String> regCreds = new HashMap<>();
        regCreds.put("email", email);
        regCreds.put("password", "CorrectPassword123");
        restTemplate.postForEntity(getBaseUrl() + "/registro", regCreds, Map.class);

        int failedAttempts = 0;
        int maxAttempts = 20;

        // Intentar m√∫ltiples logins incorrectos
        for (int i = 0; i < maxAttempts; i++) {
            Map<String, String> credentials = new HashMap<>();
            credentials.put("email", email);
            credentials.put("password", "WrongPassword" + i);

            ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl() + "/login",
                credentials,
                Map.class
            );

            if (response.getStatusCode().value() == 401) {
                failedAttempts++;
            }
        }

        // Advertencia si no hay protecci√≥n contra brute force
        if (failedAttempts == maxAttempts) {
            System.out.println("‚ö†Ô∏è SEC08: ADVERTENCIA - No hay l√≠mite de intentos de login detectado");
            System.out.println("   Recomendaci√≥n: Implementar rate limiting o account lockout");
        } else {
            System.out.println("‚úÖ SEC08: Protecci√≥n contra brute force detectada");
        }
    }

    // =====================================================
    // OWASP A05:2021 - SECURITY MISCONFIGURATION
    // =====================================================

    @Test
    @Order(9)
    @DisplayName("SEC09 - Headers de seguridad HTTP")
    void testSecurityHeaders() {
        ResponseEntity<String> response = restTemplate.getForEntity(
            getBaseUrl() + "/obtener_info_financiera",
            String.class
        );

        HttpHeaders headers = response.getHeaders();

        // Verificar headers de seguridad importantes
        List<String> warnings = new ArrayList<>();

        if (!headers.containsKey("X-Content-Type-Options")) {
            warnings.add("Falta header X-Content-Type-Options");
        }
        if (!headers.containsKey("X-Frame-Options")) {
            warnings.add("Falta header X-Frame-Options (protecci√≥n contra clickjacking)");
        }
        if (!headers.containsKey("X-XSS-Protection")) {
            warnings.add("Falta header X-XSS-Protection");
        }
        if (!headers.containsKey("Strict-Transport-Security")) {
            warnings.add("Falta header HSTS (Strict-Transport-Security)");
        }

        if (!warnings.isEmpty()) {
            System.out.println("‚ö†Ô∏è SEC09: Headers de seguridad faltantes:");
            warnings.forEach(w -> System.out.println("   - " + w));
        } else {
            System.out.println("‚úÖ SEC09: Todos los headers de seguridad presentes");
        }
    }

    @Test
    @Order(10)
    @DisplayName("SEC10 - Informaci√≥n sensible en errores")
    void testSensitiveDataInErrors() {
        Map<String, String> credentials = new HashMap<>();
        credentials.put("email", "nonexistent@example.com");
        credentials.put("password", "password");

        ResponseEntity<Map> response = restTemplate.postForEntity(
            getBaseUrl() + "/login",
            credentials,
            Map.class
        );

        String errorMessage = (String) response.getBody().get("error");

        // Verificar que no se expone informaci√≥n sensible
        List<String> sensitiveKeywords = Arrays.asList(
            "database", "sql", "query", "exception", "stack", "java.", 
            "org.springframework", "jdbc", "hibernate"
        );

        boolean leaksSensitiveInfo = sensitiveKeywords.stream()
            .anyMatch(keyword -> errorMessage.toLowerCase().contains(keyword.toLowerCase()));

        assertFalse(leaksSensitiveInfo,
            "‚ùå VULNERABILIDAD: Mensaje de error expone informaci√≥n t√©cnica sensible: " + errorMessage);

        System.out.println("‚úÖ SEC10: Mensajes de error no exponen informaci√≥n sensible");
    }

    // =====================================================
    // OWASP A07:2021 - IDENTIFICATION AND AUTHENTICATION FAILURES
    // =====================================================

    @Test
    @Order(11)
    @DisplayName("SEC11 - Contrase√±as d√©biles deben ser rechazadas")
    void testWeakPasswordRejection() {
        String[] weakPasswords = {
            "123456",
            "password",
            "12345678",
            "qwerty",
            "abc123"
        };

        int acceptedWeakPasswords = 0;

        for (String weakPwd : weakPasswords) {
            Map<String, String> credentials = new HashMap<>();
            credentials.put("email", "weak" + weakPwd + "@example.com");
            credentials.put("password", weakPwd);

            ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl() + "/registro",
                credentials,
                Map.class
            );

            if (response.getStatusCode().is2xxSuccessful()) {
                acceptedWeakPasswords++;
            }
        }

        if (acceptedWeakPasswords > 0) {
            System.out.println("‚ö†Ô∏è SEC11: ADVERTENCIA - " + acceptedWeakPasswords + 
                " contrase√±as d√©biles fueron aceptadas");
            System.out.println("   Recomendaci√≥n: Implementar pol√≠tica de contrase√±as fuertes");
        } else {
            System.out.println("‚úÖ SEC11: Contrase√±as d√©biles rechazadas correctamente");
        }
    }

    @Test
    @Order(12)
    @DisplayName("SEC12 - Reutilizaci√≥n de sesi√≥n despu√©s de logout")
    void testSessionReuseAfterLogout() {
        // Crear y usar token
        HttpHeaders headers = new HttpHeaders();
        headers.set("x-access-token", validToken);
        HttpEntity<Map<String, Object>> request = new HttpEntity<>(new HashMap<>(), headers);

        ResponseEntity<Map> response1 = restTemplate.postForEntity(
            getBaseUrl() + "/info_financiera",
            request,
            Map.class
        );

        assertTrue(response1.getStatusCode().is2xxSuccessful(),
            "Token v√°lido deber√≠a funcionar");

        // Si hubiera endpoint de logout, el token deber√≠a invalidarse
        // Como no existe, esto es una recomendaci√≥n
        System.out.println("‚ö†Ô∏è SEC12: Recomendaci√≥n - Implementar endpoint /logout para invalidar tokens");
    }

    // =====================================================
    // INPUT VALIDATION
    // =====================================================

    @Test
    @Order(13)
    @DisplayName("SEC13 - Validaci√≥n de tama√±o de input")
    void testInputSizeValidation() {
        // Crear string muy largo (ataque de denegaci√≥n de servicio)
        String veryLongString = "A".repeat(10000);

        Map<String, String> credentials = new HashMap<>();
        credentials.put("email", veryLongString + "@example.com");
        credentials.put("password", "password");

        ResponseEntity<Map> response = restTemplate.postForEntity(
            getBaseUrl() + "/registro",
            credentials,
            Map.class
        );

        assertTrue(response.getStatusCode().is4xxClientError(),
            "‚ùå VULNERABILIDAD: No hay validaci√≥n de tama√±o de input");

        System.out.println("‚úÖ SEC13: Validaci√≥n de tama√±o de input funcionando");
    }

    @Test
    @Order(14)
    @DisplayName("SEC14 - Validaci√≥n de formato de email")
    void testEmailFormatValidation() {
        String[] invalidEmails = {
            "notanemail",
            "@example.com",
            "user@",
            "user space@example.com",
            "user..name@example.com"
        };

        int acceptedInvalidEmails = 0;

        for (String email : invalidEmails) {
            Map<String, String> credentials = new HashMap<>();
            credentials.put("email", email);
            credentials.put("password", "password123");

            ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl() + "/registro",
                credentials,
                Map.class
            );

            if (response.getStatusCode().is2xxSuccessful()) {
                acceptedInvalidEmails++;
                System.out.println("‚ö†Ô∏è Email inv√°lido aceptado: " + email);
            }
        }

        if (acceptedInvalidEmails > 0) {
            System.out.println("‚ö†Ô∏è SEC14: " + acceptedInvalidEmails + " emails inv√°lidos aceptados");
        } else {
            System.out.println("‚úÖ SEC14: Validaci√≥n de formato de email correcta");
        }
    }

    @Test
    @Order(15)
    @DisplayName("SEC15 - Reporte de Seguridad General")
    void testSecurityReport() {
        System.out.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("üìã REPORTE DE SEGURIDAD - OWASP TOP 10");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("‚úÖ A01 - Broken Access Control: VERIFICADO");
        System.out.println("‚úÖ A02 - Cryptographic Failures: VERIFICADO");
        System.out.println("‚úÖ A03 - Injection: VERIFICADO");
        System.out.println("‚ö†Ô∏è A04 - Insecure Design: PARCIAL (falta rate limiting)");
        System.out.println("‚ö†Ô∏è A05 - Security Misconfiguration: PARCIAL (faltan headers)");
        System.out.println("‚úÖ A07 - Authentication Failures: VERIFICADO");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    }
}